diff --git a/include/libmkv.h b/include/libmkv.h
index 4bd6f8c..146a91f 100644
--- a/include/libmkv.h
+++ b/include/libmkv.h
@@ -216,6 +216,7 @@ struct mk_TrackConfig_s {
 mk_Writer *mk_createWriter(const char *filename, int64_t timescale,
 						   uint8_t vlc_compat);
 mk_Track *mk_createTrack(mk_Writer *w, mk_TrackConfig *tc);
+int mk_updateTrackPrivateData(mk_Writer *w, mk_Track *track, uint8_t * data, int size );
 int mk_writeHeader(mk_Writer *w, const char *writingApp);
 int mk_startFrame(mk_Writer *w, mk_Track *track);
 int mk_flushFrame(mk_Writer *w, mk_Track *track);
diff --git a/src/matroska.c b/src/matroska.c
index f61b6f2..b14fd4c 100644
--- a/src/matroska.c
+++ b/src/matroska.c
@@ -171,8 +171,17 @@ int mk_writeHeader(mk_Writer *w, const char *writingApp)
 
 	w->seek_data.tracks = w->root->d_cur - w->segment_ptr;
 
-	if (w->tracks)
-		CHECK(mk_closeContext(w->tracks, 0));
+	if (w->tracks) {
+		mk_Track * tk;
+		int i;
+
+		CHECK(mk_closeContext(w->tracks, &offset));
+		for (i = 0; i < w->num_tracks; i++) {
+			tk = w->tracks_arr[i];
+			if (tk->private_data_size)
+				tk->private_data_ptr += offset;
+		}
+	}
 
 	CHECK(mk_flushContextData(w->root));
 
@@ -487,12 +496,8 @@ int mk_close(mk_Writer *w)
 
 	for (i = w->num_tracks - 1; i >= 0; i--) {
 		tk = w->tracks_arr[i];
-		w->tracks_arr[i] = NULL;
-		--w->num_tracks;
 		if (mk_flushFrame(w, tk) < 0)
 			ret = -1;
-		free(tk);
-		tk = NULL;
 	}
 
 	if (mk_closeCluster(w) < 0)
@@ -611,6 +616,24 @@ int mk_close(mk_Writer *w)
 			ret = -1;
 	}
 
+    /* update any track private data that may have changed */
+	for (i = w->num_tracks - 1; i >= 0; i--) {
+		tk = w->tracks_arr[i];
+		if (tk->private_data_size && tk->private_data)
+		{
+			if (mk_seekFile(w, tk->private_data_ptr) < 0)
+				ret = -1;
+			if (mk_writeBin(w->root, MATROSKA_ID_CODECPRIVATE,
+							tk->private_data, tk->private_data_size) < 0 ||
+				mk_flushContextData(w->root) < 0)
+				ret = -1;
+			free(tk->private_data);
+        }
+		w->tracks_arr[i] = NULL;
+		--w->num_tracks;
+		free(tk);
+	}
+
 	if (mk_closeContext(w->root, 0) < 0)
 		ret = -1;
 	mk_destroyContexts(w);
diff --git a/src/matroska.h b/src/matroska.h
index 515c5ab..2e1eb2f 100644
--- a/src/matroska.h
+++ b/src/matroska.h
@@ -269,6 +269,9 @@ struct mk_Track_s {
 	uint64_t default_duration;
 	mk_TrackType track_type;
 	int64_t prev_cue_pos;
+	uint8_t *private_data;
+	unsigned private_data_size;
+	int64_t private_data_ptr;
 
 	struct {
 		mk_Context *data;
diff --git a/src/tracks.c b/src/tracks.c
index d9fc38b..0e224e4 100644
--- a/src/tracks.c
+++ b/src/tracks.c
@@ -81,6 +81,8 @@ mk_Track *mk_createTrack(mk_Writer *w, mk_TrackConfig *tc)
 		return NULL;
 	if (tc->codecPrivateSize && (tc->codecPrivate != NULL)) {
 		/* CodecPrivate */
+		track->private_data_size = tc->codecPrivateSize;
+		track->private_data_ptr = ti->d_cur;
 		if (mk_writeBin(ti, MATROSKA_ID_CODECPRIVATE, tc->codecPrivate, tc->codecPrivateSize) < 0)
 			return NULL;
 	}
@@ -191,17 +193,40 @@ mk_Track *mk_createTrack(mk_Writer *w, mk_TrackConfig *tc)
 			return NULL;
 	}
 
-	if (mk_closeContext(ti, 0) < 0)
+	int64_t offset = 0;
+	if (mk_closeContext(ti, &offset) < 0)
 		return NULL;
+	track->private_data_ptr += offset;
 
 	return track;
 }
 
+int mk_updateTrackPrivateData(mk_Writer *w, mk_Track *track, uint8_t * data, int size )
+{
+	/* can not write data larger than was previously reserved */
+	if (size > track->private_data_size)
+		return -1;
+
+	if (track->private_data == NULL)
+		track->private_data = calloc(1, track->private_data_size);
+	memcpy(track->private_data, data, size);
+}
+
 int mk_writeTracks(mk_Writer *w, mk_Context *tracks)
 {
+	int i;
+	mk_Track * tk;
+	int64_t offset = 0;
+
 	w->seek_data.tracks = w->root->d_cur;
 
-	CHECK(mk_closeContext(w->tracks, 0));
+	CHECK(mk_closeContext(w->tracks, &offset));
+
+	for (i = 0; i < w->num_tracks; i++) {
+		tk = w->tracks_arr[i];
+		if (tk->private_data_size)
+			tk->private_data_ptr += offset;
+	}
 
 	return 0;
 }
